%
%    This program is free software; you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation; either version 2 of the License, or
%    (at your option) any later version.
%
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%

% Version: $Revision$

For most users, the existing Weka framework will be sufficient to perform the
task at hand, offering a wide range of filters, classifiers, clusterers, etc.
Researchers, on the other hand, might want to add new algorithms and compare
them against existing ones. The framework with its existing algorithms is not
set in stone, but basically one big plugin framework. Furthermore, Weka supports
an automatic discovery of classes in your classpath, managed by the
\texttt{GenericPropertiesCreator}. This allows you to quickly add new
classifiers, filters, etc. to the existing framework.

Though algorithms like clusterers, associators, data generators, estimators and
attribute selection are not covered in this chapter, their implemention is very
similar to the one of implementing a classifier. You basically choose a
superclass to derive your new algorithm from and then implement additional
interfaces, if necessary. Just check out the other algorithms that are already
implemented.

The section covering the GenericObjectEditor (see chapter
\ref{genericobjecteditor}) shows you how to tell Weka where to find your
class(es) and therefore making them available in the GUI
(Explorer/Experimenter) via the GenericObjectEditor.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Writing a new Classifier %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Writing a new Classifier}
\subsection{Choosing the base class}
The ancestor of all classifiers in Weka is \texttt{weka.classifiers.Classifier},
an abstract class. Your new classifier must be derived from this class at
least to be visible through the GenericObjectEditor. But in order to
make implementation of new classifiers even easier, Weka comes already with a
range of other abstract classes derived from
\texttt{weka.classifiers.Classifier}. In the following an overview that will
help you decide what base class to use for your classifier. For better
readability, the \texttt{weka.classifiers} prefix was dropped from the class
names:
\begin{tight_itemize}
  \item simple classifier
	\begin{tight_itemize}
	  \item \texttt{Classifier} -- not randomizable
	  \item \texttt{RandomizableClassifier} -- randomizable
	\end{tight_itemize}
  \item meta classifier
	\begin{tight_itemize}
	  \item single base classifier
		\begin{tight_itemize}
		  \item \texttt{SingleClassifierEnhancer} -- not randomizable, not
iterated
		  \item \texttt{RandomizableSingleClassifierEnhancer} -- randomizable,
not iterated
		  \item \texttt{IteratedSingleClassifierEnhancer} -- not randomizable,
iterated
		  \item \texttt{RandomizableIteratedSingleClassifierEnhancer} --
randomizable, iterated
		\end{tight_itemize}
	  \item multiple base classifiers
		\begin{tight_itemize}
		  \item \texttt{MultipleClassifiersCombiner} -- not randomizable
		  \item \texttt{RandomizableMultipleClassifiersCombiner} -- randomizable
		\end{tight_itemize}
	\end{tight_itemize}
\end{tight_itemize}
If you check out the Javadoc of those superclasses, you will see all the
classifiers that are derived from them.

\subsection{Additional interfaces}
The abstract classes listed above basically just implement various combinations
of the following two interfaces:
\begin{tight_itemize}
  \item \texttt{weka.core.Randomizable} -- to allow (seeded) randomization
taking place
  \item \texttt{weka.classifiers.IterativeClassifier} -- to make the classifier
an iterated one
\end{tight_itemize}

\newpage
\noindent But these interfaces are not the only ones that can be implemented by
a classifier. Here is a list for further interfaces:
\begin{tight_itemize}
  \item \texttt{weka.core.AdditionalMeasureProducer} -- the classifier returns
additional information, e.g., \texttt{J48} returns the tree size with this
method.
  \item \texttt{weka.core.WeightedInstancesHandler} -- denotes that the
classifier can handle datasets with weighted \texttt{Instance} objects (the
default weight is 1.0).
  \item \texttt{weka.core.TechnicalInformationHandler} -- for returning paper
references, publications this classifier is based on.
  \item \texttt{weka.classifiers.Sourcable} -- classifiers implementing this
interface can return Java code of a built model, which can be used elsewhere.
  \item \texttt{weka.classifiers.UpdateableClassifier} -- for classifiers that
can be trained incrementally, i.e., row by row like
\texttt{NaiveBayesUpdateable}.
\end{tight_itemize}

\subsection{Packages}
A few comments about the different sub-packages in the \texttt{weka.classifiers}
package:
\begin{tight_itemize}
  \item \texttt{bayes} -- contains bayesian classifiers, e.g.,
\texttt{NaiveBayes}
  \item \texttt{evaluation} -- classes related to evaluation, e.g., cost
matrix, threshold curve
  \item \texttt{functions} -- e.g., Support Vector Machines, regression
algorithms, neural nets
  \item \texttt{lazy} -- ``learning'' is performed at prediction time, e.g.,
k-nearest neighbor (k-NN)
  \item \texttt{meta} -- Meta classifiers that use a base classifier as input,
e.g., boosting or bagging
  \item \texttt{mi} -- classifiers that handle multi-instance data
  \item \texttt{misc} -- various classifiers that don't fit in any another
category
  \item \texttt{rules} -- rule-based classifiers, e.g., ZeroR
  \item \texttt{trees} -- tree classifiers, like decision trees
\end{tight_itemize}

\subsection{Implementation}
In the following you will find information on what methods need to be
implemented and other coding guidelines for methods, option handling and
documentation of the source code.

\subsubsection{Methods}
This section explains what methods need to be implemented in general and more
specialized ones in case of meta-classifiers (either with single or multiple
base-classifiers).

\subsubsection*{General}
Here is an overview of methods that your new classifier needs to implemented in
order to integrate nicely into the Weka framework:

\paragraph{globalInfo()} displays a short description, that is displayed in the
GUI, like the Explorer or Experimenter. How long this description will be is
really up to you, but it should be sufficient to understand the classifier's
underlying algorithm. If the classifier implements the
\texttt{weka.core.TechnicalInformationHandler} interface then you could refer
to the publication(s) by extending the returned the returned string by
\texttt{getTechnicalInformation().toString()}.

\newpage
\paragraph{listOptions()} returns an \texttt{java.util.Enumeration} of
\texttt{weka.core.Option} objects. This enumeration is used to display the help
on the command-line, hence it needs to returns the \texttt{Option} objects of
the superclass as well.

\paragraph{setOptions(String[])} parses the options that the classifier
would receive from a command-line invocation. A parameter and argument are
always two elements in the string array (a common mistake is to use a single
string cell for both of them). You can use the methods \texttt{getOption} and
\texttt{getFlag} of the \texttt{weka.core.Utils} class to retrieve the values
of an option or to ascertain whether a flag is present. But note, that these
calls \textbf{remove} the option and, if applicable, the argument from the
string array (``destructive''). The last call in the \texttt{setOptions}
methods should always be the \texttt{super.setOptions(String[])} one, in order
to pass on any other arguments still present in the array to the superclass.
The following code snippet just parses the only option ``alpha'' that the
classifier defines:
\begin{verbatim}
  import weka.core.Utils;
  ...
  public void setOptions(String[] options) throws Exception {
    String tmpStr = Utils.getOption("alpha", options);
    if (tmpStr.length() == 0) {
      setAlpha(0.75);
    }
    else {
      setAlpha(Double.parseDouble(tmpStr));
    }
     super.setOptions(options);
  }
\end{verbatim}

\paragraph{getOptions()} returns a string array of command-line options that
resemble the current classifier setup. Supplying this array to the
\texttt{setOptions(String[])} method must result in the same configuration.
This method will get called in the GUI when copying a classifier setup to the
clipboard. Since handling of arrays is a bit cumbersome in Java (due to fixed
size), using an instance of \texttt{java.util.Vector} is a lot easier for
creating the array that needs to be returned. The following code snippet just
adds the only option ``alpha'' that the classifier defines to the array that is
being returned:
\begin{verbatim}
  import java.util.Arrays;
  import java.util.Vector;
  ...
  public String[] getOptions() {
    Vector<String> result = new Vector<String>();
    result.add("-alpha");
    result.add("" + getAlpha());
    result.addAll(Arrays.asList(super.getOptions()));
    return result.toArray(new String[result.size()]);
  }
\end{verbatim}
Note, that the \texttt{getOptions()} method requires you to add the preceding
dash for an option, opposed to the \texttt{getOption}/\texttt{getFlag} calls in
the \texttt{setOptions} method.

\newpage
\paragraph{getCapabilities()} returns meta-information on what type of data the
classifier can handle, in regards to attributes and class attributes. See
section ``Capabilities'' on page \pageref{classifier_capabilities} for more
information.

\paragraph{buildClassifier(Instances)} builds the model from scratch with the
provided dataset. Each subsequent call of this method \textbf{must} result in
the same model being built. The \texttt{buildClassifier} method also tests
whether the supplied data can be handled at all by the classifier, utilizing
the capabilities returned by the \texttt{getCapabilities()} method:
\begin{verbatim}
  public void buildClassifier(Instances data) throws Exception {
    // test data against capabilities
    getCapabilities().testWithFail(data);
    // remove instances with missing class value,
    // but don't modify original data
    data = new Instances(data);
    data.deleteWithMissingClass();
    // actual model generation
    ...
  }
\end{verbatim}

\paragraph{toString()} is used for outputting the built model. This is not
required, but it is useful for the user to see properties of the model. Decision
trees normally ouput the tree, support vector machines the support vectors and
rule-based classifiers the generated rules.

\paragraph{distributionForInstance(Instance)} returns the class probabilities
array of the prediction for the given \texttt{weka.core.Instance} object. If
your classifier handles nominal class attributes, then you need to override
this method.

\paragraph{classifyInstance(Instance)} returns the classification or regression
for the given \texttt{weka.core.Instance} object. In case of a \textit{nominal}
class attribute, this method returns the index of the class label that got
predicted. You do not need to override this method in this case as the
\texttt{weka.classifiers.Classifier} superclass already determines the class
label index based on the probabilities array that the
\texttt{distributionForInstance(Instance)} method returns (it returns the index
in the array with the highest probability; in case of ties the first one). For
\textit{numeric} class attributes, you need to override this method, as it
has to return the regression value predicted by the model.

\paragraph{main(String[])} executes the classifier from command-line. If your
new algorithm is called \texttt{FunkyClassifier}, then use the following code
as your \texttt{main} method:
\begin{verbatim}
  /**
   * Main method for executing this classifier.
   *
   * @param args the options, use "-h" to display options
   */
  public static void main(String[] args) {
    runClassifier(new FunkyClassifier(), args);
  }
\end{verbatim}
Note: the static method \texttt{runClassifier} (defined in the abstract
superclass \texttt{weka.classifiers.Classifier}) handles all the appropriate
calls and catches and processes any exceptions as well.

\newpage
\subsubsection*{Meta-classifiers}
Meta-classifiers define a range of other methods that you might want to
override. Normally, this should not be the case. But if your classifier requires
the base-classifier(s) to be of a certain type, you can override the specific
set-method and add additional checks.

\subsubsection*{SingleClassifierEnhancer}
The following methods are used for handling the single base-classifier of this
meta-classifier.

\paragraph{defaultClassifierString} returns the class name of the classifier
that is used as the default one for this meta-classifier.

\paragraph{setClassifier(Classifier)} sets the classifier object. Override this
method if you required further checks, like that the classifiers needs to be of
a certain class. This is necessary, if you still want to allow the user to
parametrize the base-classifier, but not choose another classifier with the
GenericObjectEditor. By aware that this method does not create a copy of the
provided classifier.

\paragraph{getClassifier()} returns the currently set classifier object. Note,
this method returns the internal object and not a copy.

\subsubsection*{MultipleClassifiersCombiner}
This meta-classifier handles its multiple base-classifiers with the following
methods:

\paragraph{setClassifiers(Classifier[])} sets the array of classifiers to use
as base-classifiers. If you require the base-classifiers to implement a certain
interface or be of a certain class, then override this method and add the
necessary checks. Note, this method does not create a copy of the array, but
just uses this reference.

\paragraph{getClassifiers()} returns the array of classifiers that is in use.
Careful, this method returns the internal array and not a copy of it.

\paragraph{getClassifier(int)} returns the classifier from the internal
classifier array specified by the given index. Once again, this method does not
return a copy of the classifier, but the actual object used by this classifier.

\newpage
\subsubsection{Guidelines}
Weka's code base requires you to follow a few rules. The following sections can
be used as guidelines in writing your code.

\subsubsection*{Parameters}
Weka has two different ways of setting/obtaining parameters of an algorithm
(both of them are unfortunately completely separated, which makes option
handling so prone to errors):
\begin{tight_enumerate}
  \item command-line options, using the \texttt{setOptions}/\texttt{getOptions}
methods
  \item using the properties through the GenericObjectEditor
\end{tight_enumerate}
In the latter case, the get- and set-method for a property must comply with 
Java Beans style in order to show up in the GUI. You need to supply three
methods for each property:
\begin{tight_itemize}
  \item \texttt{public void set\textit{<PropertyName>}(\textit{<Type>})} --
checks whether the supplied value is valid and only then updates the
corresponding member variable, in any other case it should ignore the value
and output a warning in the console or throw an
\texttt{IllegalArgumentException}.
  \item \texttt{public \textit{<Type>} get\textit{<PropertyName>}()} --
performs any necessary conversions of the internal value and returns it.
  \item \texttt{public String \textit{<propertyName>}TipText()} -- returns the
help text that is available through the GUI. Should be the same as on the
command-line. Note: everything after the first period ``.'' gets truncated from
the tool tip that pops up in the GUI.
\end{tight_itemize}
With a property called ``alpha'' of type ``double'', we get the following
method signatures:
\begin{tight_itemize}
  \item \texttt{public void setAlpha(double)}
  \item \texttt{public double getAlpha()}
  \item \texttt{public String alphaTipText()}
\end{tight_itemize}
These get- and set-methods should be used in the \texttt{getOptions} and
\texttt{setOptions} methods as well, to impose the same checks when
getting/setting parameters.

\subsubsection*{Randomization}
In order to get repeatable experiments, one is not allowed to use unseeded
random number generators like \texttt{Math.random()}. Instead, one has to
instantiate a \texttt{java.util.Random} object in the
\texttt{buildClassifier(Instances)} method with a specific seed value. The seed
value can be user supplied, of course, which all the \texttt{Randomizable...}
abstract classifiers already implement.

\newpage
\subsubsection*{Capabilities}
\label{classifier_capabilities}
By default, the \texttt{weka.classifiers.Classifier} superclass returns an
object that denotes that the classifier can handle \textbf{any} type of data.
This is useful for rapid implementation of new algorithms, but also very
dangerous. If you do not specifically define what type of data can be handled by
your classifier, you can end up with meaningless models. This can happen if you
devise a new classifier which is supposed to handle only numeric attributes. By
using the \texttt{value(int/Attribute)} method of a \texttt{weka.core.Instance}
to obtain the numeric value of an attribute, you also obtain the internal format
of nominal, string and relational attributes. Of course, treating these
attribute types as numeric ones does not make any sense. Hence it is highly
recommended (and required for contributions) to override this method in your own
classifier. \\

\noindent There are three different types of capabilities that one can supply:
\begin{tight_enumerate}
  \item \textit{attribute related} -- e.g., nominal, numeric, date, missing
values, ...
  \item \textit{class attribute related} -- e.g., no-class, nominal, numeric,
missing class values, ...
  \item \textit{miscellaneous} -- e.g., only multi-instance data, minimum number
of instances in the training data
\end{tight_enumerate}
There are some special cases:
\begin{tight_itemize}
  \item \textit{incremental classifiers} -- need to set the minimum number of
instances in the training data to 0, since the default is 1: \\
  \texttt{setMinimumNumberInstances(0)}
  
  \item \textit{multi-instance classifiers} -- in order to signal that the
special multi-instance format (\textit{bag-id, bag-data, class}) is used, they
need to enable this capability: \\
  \texttt{enable(Capability.ONLY\_MULTIINSTANCE)} \\
  These classifiers also need to implement the multi-instance specific interface
\texttt{weka.core.MultiInstanceCapabilitiesHandler}, which returns the
capabilities for the \textit{bag-data}.

  \item \textit{cluster algorithms} -- since clusterers are unsupervised
algorithms, they cannot process data with the class attribute set. The
capability that denotes that an algorithm can handle data without a class
attribute is \texttt{Capability.NO\_CLASS}
\end{tight_itemize}
And a note on enabling/disabling \textit{nominal attributes} or \textit{nominal
class attributes}. These operations automatically enable/disable the
\textit{binary}, \textit{unary} and \textit{empty nominal} capabilities as well.

\newpage
\subsubsection*{Simple classifier}
A classifier that handles only numeric classes and numeric and nominal
attributes, but no missing values at all, would configure the
\texttt{Capabilities} object like this:
\begin{verbatim}
  public Capabilities getCapabilities() {
    Capabilities result = new Capabilities(this);
    // attributes
    result.enable(Capability.NOMINAL_ATTRIBUTES);
    result.enable(Capability.NUMERIC_ATTRIBUTES);
    // class
    result.enable(Capability.NUMERIC_CLASS);
    return result;
  }
\end{verbatim}
Another classifier, that only handles binary classes and only nominal
attributes and missing values, would implement the \texttt{getCapabilities()}
method as follows:
\begin{verbatim}
  public Capabilities getCapabilities() {
    Capabilities result = new Capabilities(this);
    // attributes
    result.enable(Capability.NOMINAL_ATTRIBUTES);
    result.enable(Capability.MISSING_VALUES);
    // class
    result.enable(Capability.BINARY_CLASS);
    result.disable(Capability.UNNARY_CLASS);
    result.enable(Capability.MISSING_CLASS_VALUES);
    return result;
  }
\end{verbatim}

\subsubsection*{Meta-classifier}
Meta-classifiers, by default, just return the capabilities of their base
classifiers - in case of descendants of the
\texttt{weka.classifier.MultipleClassifiersCombiner}, an \textbf{AND} over all
the \texttt{Capabilities} of the base classifiers is returned.

Due to this behavior, the \texttt{Capabilities} depend (normally) only on the
currently configured base classifier(s). To \textit{soften} filtering for
certain behavior, meta-classifiers also define so-called \textit{Dependencies}
on a per-Capability basis. These dependencies tell the filter that even though a
certain capability is not supported right now, it is possible that it will be
supported with a different base classifier. By default, all
\texttt{Capabilities} are initialized as \textit{Dependencies}.

\texttt{weka.classifiers.meta.LogitBoost}, e.g., is restricted to nominal
classes. For that reason it disables the \textit{Dependencies} for the class:
{\small \begin{verbatim}
    result.disableAllClasses();              // disable all class types
    result.disableAllClassDependencies();    // no dependencies!
    result.enable(Capability.NOMINAL_CLASS); // only nominal classes allowed
\end{verbatim}}

\newpage
\subsubsection*{Javadoc}
\label{classifier_javadoc}
In order to keep a high code-quality and maintenance easy, the code needs to
be well documented. This includes the following Javadoc requirements:
\begin{tight_itemize}
  \item \textbf{class}
    \begin{tight_itemize}
      \item description of the classifier
      \item listing of command-line parameters
      \item publication(s), if applicable
      \item \texttt{@author} and \texttt{@version} tag
    \end{tight_itemize}

  \item \textbf{methods} (all, not just public)
    \begin{tight_itemize}
      \item each \textit{parameter} is documented
      \item \textit{return} value, if applicable, is documented
      \item \textit{exception(s)} are documented
      \item the \texttt{setOptions(String[])} method also lists the
command-line parameters
    \end{tight_itemize}
\end{tight_itemize}
Most of the \textit{class}-related and the \texttt{setOptions} Javadoc is
already available through the source code:
\begin{tight_itemize}
  \item description of the classifier -- \texttt{globalInfo()}
  \item listing of command-line parameters -- \texttt{listOptions()}
  \item publication(s), if applicable -- \texttt{getTechnicalInformation()}
\end{tight_itemize}
In order to avoid manual syncing, Weka comes with some tools for updating the
Javadoc automatically. The following tools take a concrete class and update its
source code (the source code directory needs to be supplied as well, of course):
\begin{tight_itemize}
  \item \texttt{weka.core.AllJavadoc} -- executes all Javadoc-producing
classes (this is the tool, you would normally use)
  \item \texttt{weka.core.GlobalInfoJavadoc} -- updates the \textit{globalInfo}
tags
  \item \texttt{weka.core.OptionHandlerJavadoc} -- updates the \textit{option}
tags
  \item \texttt{weka.core.TechnicalInformationHandlerJavadoc} -- updates the
\textit{technical} tags (plain text and BibTeX)
\end{tight_itemize}
These tools look for specific comment tags in the source code and replace
everything in between the start and end tag with the documentation obtained
from the actual class.
\begin{tight_itemize}
  \item description of the classifier
    \begin{verbatim}
    <!-- globalinfo-start -->
    will be automatically replaced
    <!-- globalinfo-end -->
    \end{verbatim}
  \item listing of command-line parameters
    \begin{verbatim}
    <!-- options-start -->
    will be automatically replaced
    <!-- options-end -->
   \end{verbatim}
  \item publication(s), if applicable
    \begin{verbatim}
    <!-- technical-bibtex-start -->
    will be automatically replaced
    <!-- technical-bibtex-end -->
    \end{verbatim}
    for a shortened, plain-text version use the following:
    \begin{verbatim}
    <!-- technical-plaintext-start -->
    will be automatically replaced
    <!-- technical-plaintext-end -->
   \end{verbatim}
\end{tight_itemize}

\newpage
\noindent Here is an example of a skeleton class Javadoc block for an imaginary
classifier that also implements the
\texttt{weka.core.TechnicalInformationHandler} interface:
\begin{verbatim}
/**
 <!-- globalinfo-start -->
 <!-- globalinfo-end -->
 *
 <!-- technical-bibtex-start -->
 <!-- technical-bibtex-end -->
 *
 <!-- options-start -->
 <!-- options-end -->
 *
 * @author John Doe (john dot doe at no dot where dot com)
 * @version $Revision$
 */
\end{verbatim}
The skeleton block for any classifier's \texttt{setOptions(String[])} method
is as follows:
\begin{verbatim}
  /**
   * Parses a given list of options.
   *
   <!-- options-start -->
   <!-- options-end -->
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
\end{verbatim}
Running the \texttt{weka.core.AllJavadoc} tool over this code will output code
with the comments filled out accordingly.

\subsubsection*{Revisions}
\label{classifier_revisions}
Classifiers implement the \texttt{weka.core.RevisionHandler} interface. This
provides the functionality of obtaining the Subversion revision from within
Java. Classifiers that are not part of the official Weka distribution
do not have to implement the method \texttt{getRevision()} as the
\texttt{weka.classifiers.Classifier} class already implements this method.
Contributions, on the other hand, need to implement it as follows, in order to
obtain the revision of this particular source file:
\begin{verbatim}
  /**
   * Returns the revision string.
   *
   * @return        the revision
   */
  public String getRevision() {
    return RevisionUtils.extract("$Revision$");
  }
\end{verbatim}
Note, a commit into Subversion will replace the ``1'' with the actual revision
number.

\subsubsection*{Testing}
In order to make sure that your classifier applies to the Weka criteria, you
should add your classifier to the junit unit test framework, i.e., by creating a
Test class. The superclass for classifier unit tests is
\texttt{weka.classifiers.AbstractClassifierTest}.

%%%%%%%%%%%%%%%%%%%%%%%%
% Writing a new Filter %
%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Writing a new Filter}
The ``work horses'' of preprocessing in WEKA are \textit{filters}. They perform
many tasks, from resampling data, to deleting and standardizing attributes. In
the following are two different approaches covered:
\begin{tight_itemize}
  \item \textbf{default} -- this is how filters had to be implemented in the
past.
  \item \textbf{simple }-- since there are mainly two types of filters, batch or
stream, additional abstract classes were introduced to speed up implementation.
\end{tight_itemize}

\subsection{Default approach}
The \textit{default} is the most flexible, but also most complicated approach
of writing a new filter. This approach has to be taken, if the filter cannot be
written using the \textit{simple} approach described further below.

\subsubsection{Implementation}
The following methods are of importance for the implementation of a filter and
explained in detail further down:
\begin{tight_itemize}
  \item \texttt{getCapabilities()}
  \item \texttt{setInputFormat(Instances)}
  \item \texttt{getInputFormat()}
  \item \texttt{setOutputFormat(Instances)}
  \item \texttt{getOutputFormat()}
  \item \texttt{input(Instance)}
  \item \texttt{bufferInput(Instance)}
  \item \texttt{push(Instance)}
  \item \texttt{output()}
  \item \texttt{batchFinished()}
  \item \texttt{flushInput()}
  \item \texttt{getRevision()}
\end{tight_itemize}
But only the following ones need normally be modified:
\begin{tight_itemize}
  \item \texttt{getCapabilities()}
  \item \texttt{setInputFormat(Instances)}
  \item \texttt{input(Instance)}
  \item \texttt{batchFinished()}
  \item \texttt{getRevision()}
\end{tight_itemize}
For more information on ``Capabilities'' see section \ref{filter_capabilities}.

\newpage
\paragraph{setInputFormat(Instances)}
With this format, the user tells the filter what format, i.e., attributes, the
input data has. This method also tests, whether the filter can actually process
this data, according to the capabilities specified in the
\texttt{getCapabilities()} method.

If the output format of the filter, i.e., the new \texttt{Instances} header, can
be determined based alone on this information, then the method should set the
output format via \texttt{setOutputFormat(Instances)} and return \texttt{true},
otherwise it has to return \texttt{false}.

\paragraph{getInputFormat()}
This method returns an \texttt{Instances} object containing all currently
buffered \texttt{Instance} objects from the input queue.

\paragraph{setOutputFormat(Instances)}
\texttt{setOutputFormat(Instances)} defines the new \texttt{Instances} header
for the output data. For filters that work on a row-basis, there should not be
any changes between the input and output format. But filters that work on
attributes, e.g., removing, adding, modifying, will affect this format. This
method must be called with the appropriate \texttt{Instances} object as
parameter, since all \texttt{Instance} objects being processed will rely on the
output format.

\paragraph{getOutputFormat()}
This method returns the currently set \texttt{Instances} object that defines the
output format. In case \texttt{setOutputFormat(Instances)} has not been called
yet, this method will return \texttt{null}.

\paragraph{input(Instance)}
The \texttt{input(Instance)} method returns \texttt{true} if the given
\texttt{Instance} can be processed straight away and can be collected
immediately via the \texttt{output()} method (after adding it to the output
queue via \texttt{push(Instance)}, of course). This is also the case if the
first batch of data has been processed and the instance belongs to the second
batch. Via \texttt{isFirstBatchDone()} one can query whether this instance is
still part of the first batch or of the second.

If the \texttt{Instance} cannot be processed immediately, e.g., the filter needs
to collect all the data first before doing some calculations, then it needs to
be buffered with \texttt{bufferInput(Instance)} until \texttt{batchFinished()}
is called.

\paragraph{bufferInput(Instance)}
In case an \texttt{Instance} cannot be processed immediately, one can use this
method to buffer them in the input queue. All buffered \texttt{Instance} objects
are available via the \texttt{getInputFormat()} method.

\paragraph{push(Instance)}
adds the given \texttt{Instance} to the output queue.

\paragraph{output()}
Returns the next \texttt{Instance} object from the output queue and removes it
from there. In case there is no \texttt{Instance} available this method returns
\texttt{null}.

\newpage
\paragraph{batchFinished()}
The \texttt{batchFinished()} method signals the end of a dataset being pushed
through the filter. In case of a filter that could not process the data of the
first batch immediately, this is the place to determine what the output format
will be (and set if via \texttt{setOutputFormat(Instances)}) and process the
actual data. The currently available data can be retrieved with the
\texttt{getInputFormat()} method. After processing the data, one needs to call
\texttt{flushInput()} to remove all the pending input data.

\paragraph{flushInput()}
\texttt{flushInput()} removes all buffered \texttt{Instance} objects from the
input queue. This method must be called after all the \texttt{Instance} objects
have been processed in the \texttt{batchFinished()} method.

\subsubsection*{Option handling}
If the filter should be able to handle commandline options, then the interface
\texttt{weka.core.OptionHandler} needs to be implemented. In addition
to that, the following code should be added at the end of the
\texttt{setOptions(String[])} method:
\begin{verbatim}
if (getInputFormat() != null) {
    setInputFormat(getInputFormat());
}
\end{verbatim}
This will inform the filter about changes in the options and therefore reset it.

\newpage
\subsubsection{Examples}
The following examples, covering batch and stream filters, are to illustrate the
filter framework and how to use it.

Unseeded random number generators like \texttt{Math.random()} should
\textbf{never} be used since they will produce different results in each run and
repeatable experiments are essential in machine learning.

\subsubsection*{BatchFilter}
This simple batch filter adds a new attribute called \textit{bla} at the end of
the dataset. The rows of this attribute contain only the row's index in the
data. Since the batch-filter need not see all the data before creating the
output format, the \texttt{setInputFormat(Instances)} sets the output format and
returns \texttt{true} (indicating that the output format can be queried
immediately). The \texttt{batchFinished()} method performs the processing of all
the data.

{\scriptsize \input{includes/BatchFilter}}

\newpage
\subsubsection*{BatchFilter2}
In contrast to the first batch filter, this one here cannot determine the output
format immediately (the number of instances in the first batch is part of the
attribute name now). This is done in the \texttt{batchFinished()} method.

{\scriptsize \input{includes/BatchFilter2}}

\newpage
\subsubsection*{BatchFilter3}
As soon as this batch filter's first batch is done, it can process
\texttt{Instance} objects immediately in the \texttt{input(Instance)} method. It
adds a new attribute which contains just a random number, but the random number
generator being used is seeded with the number of instances from the first
batch.

{\scriptsize \input{includes/BatchFilter3}}

\newpage
\subsubsection*{StreamFilter}
This stream filter adds a random number at the end of each \texttt{Instance} of
the input data. Since this does not rely on having access to the full data of
the first batch, the output format is accessible immediately after using
\texttt{setInputFormat(Instances)}. All the \texttt{Instance} objects are
immediately processed in \texttt{input(Instance)} via the
\texttt{convertInstance(Instance)} method, which pushes them immediately to the
output queue.

{\scriptsize \input{includes/StreamFilter}}

\newpage
\subsection{Simple approach}
The base filters and interfaces are all located in the following package:
\begin{verbatim}
 weka.filters
\end{verbatim}
One can basically distinguish between two different kinds of filters:
\begin{tight_itemize}
  \item \textbf{batch filters} -- they need to see the whole dataset before they
can start processing it, which they do in one go
  \item \textbf{stream filters} -- they can start producing output right away
and the data just passes through while being modified
\end{tight_itemize}
You can subclass one of the following abstract filters, depending on the kind of
classifier you want to implement:
\begin{tight_itemize}
  \item \texttt{weka.filters.SimpleBatchFilter}
  \item \texttt{weka.filters.SimpleStreamFilter}
\end{tight_itemize}
These filters simplify the rather general and complex framework introduced by
the abstract superclass \texttt{weka.filters.Filter}. One only needs to
implement a couple of abstract methods that will process the actual data and
override, if necessary, a few existing methods for option handling.

\subsubsection{SimpleBatchFilter}
Only the following abstract methods need to be implemented:
\begin{tight_itemize}
  \item \texttt{globalInfo()} -- returns a short description of what the
filter does; will be displayed in the GUI
  \item \texttt{determineOutputFormat(Instances)} -- generates the new
format, based on the input data
  \item \texttt{process(Instances)} -- processes the whole dataset in one
go
  \item \texttt{getRevision()} -- returns the Subversion revision information,
see section Revisions
\end{tight_itemize}
If more options are necessary, then the following methods need to be overridden:
\begin{tight_itemize}
  \item \texttt{listOptions()} -- returns an enumeration of the available
options; these are printed if one calls the filter with the -h option
  \item \texttt{setOptions(String[])} -- parses the given option array,
that were passed from commandline
  \item \texttt{getOptions()} -- returns an array of options, resembling
the current setup of the filter
\end{tight_itemize}

\newpage
In the following an example implementation that adds an additional attribute at
the end, containing the index of the processed instance:

{\footnotesize \input{includes/SimpleBatch}}

\newpage
\subsubsection{SimpleStreamFilter}
Only the following abstract methods need to be implemented:
\begin{tight_itemize}
  \item \texttt{globalInfo()} -- returns a short description of what the filter
does; will be displayed in the GUI
  \item \texttt{determineOutputFormat(Instances)} -- generates the new
format, based on the input data
  \item \texttt{process(Instance)} -- processes a single instance and turns it
from the old format into the new one
  \item \texttt{getRevision()} -- returns the Subversion revision
information, see section Revisions
\end{tight_itemize}
The \texttt{reset()} method is only used, since the random number generator
needs to be re-initialized in order to obtain repeatable results.

If more options are necessary, then the following methods need to be overridden:
\begin{tight_itemize}
  \item \texttt{listOptions()} -- returns an enumeration of the available
options; these are printed if one calls the filter with the -h option
  \item \texttt{setOptions(String[])} -- parses the given option array,
that were passed from commandline
  \item \texttt{getOptions()} -- returns an array of options, resembling the
current setup of the filter
\end{tight_itemize}

\newpage
In the following an example implementation of a stream filter that adds an extra
attribute at the end, which is filled with random numbers:

{\footnotesize \input{includes/SimpleStream}}

\noindent A real-world implementation of a stream filter is the
\texttt{MultiFilter} class (package \texttt{weka.filters}), which passes the
data through all the filters it contains. Depending on whether all the used
filters are streamable or not, it acts either as a \textit{stream} filter or as
\textit{batch} filter.

\newpage
\subsubsection{Internals}
Some useful methods of the filter classes:
\begin{tight_itemize}
  \item \texttt{isNewBatch()} -- returns \texttt{true} if an instance of the
filter was just instantiated via new or a new batch was started via the
\texttt{batchFinished()} method.
  \item \texttt{isFirstBatchDone()} -- returns \texttt{true} as soon as the
first batch was finished via the \texttt{batchFinished()} method. Useful for
supervised filters, which should not be altered after being trained with the
first batch of instances.
\end{tight_itemize}

\subsection{Capabilities}
\label{filter_capabilities}
Filters implement the \texttt{weka.core.CapabilitiesHandler} interface like the
classifiers. This method returns what kind of data the filter is able to
process. Needs to be adapted for each individual filter, since the default
implementation allows the processing of all kinds of attributes and classes,
otherwise correct functioning of the filter cannot be guaranteed. See section
``Capabilities'' on page \pageref{classifier_capabilities} for more information.

\subsection{Packages}
A few comments about the different filter sub-packages:
\begin{tight_itemize}
  \item \textbf{supervised} -- contains supervised filters, i.e., filters that
take class distributions into account. Must implement the
\texttt{weka.filters.SupervisedFilter} interface.
  \begin{tight_itemize}
	\item \textbf{attribute} -- filters that work column-wise.
	\item \textbf{instance} -- filters that work row-wise.
  \end{tight_itemize}
  \item \textbf{unsupervised} -- contains unsupervised filters, i.e., they work
without taking any class distributions into account. The filter must implement
the \texttt{weka.filters.UnsupervisedFilter} interface.
  \begin{tight_itemize}
	\item \textbf{attribute} -- filters that work column-wise.
	\item \textbf{instance} -- filters that work row-wise.
  \end{tight_itemize}
\end{tight_itemize}

\subsubsection*{Javadoc}
The Javadoc generation works the same as with classifiers. See section
``Javadoc'' on page \pageref{classifier_javadoc} for more information.

\subsection{Revisions}
Filters, like classifiers, implement the \texttt{weka.core.RevisionHandler}
interface. This provides the functionality of obtaining the Subversion revision
from within Java. Filters that are not part of the official Weka distribution
do not have to implement the method \texttt{getRevision()} as the
\texttt{weka.filters.Filter} class already implements this method.
Contributions, on the other hand, need to implement it, in order to
obtain the revision of this particular source file. See section ``Revisions''
on page \pageref{classifier_revisions}.

\newpage
\subsection{Testing}
Weka provides already a test framework to ensure the basic functionality of a
filter. It is essential for the filter to pass these tests.

\subsubsection{Option handling}
You can check the option handling of your filter with the following tool from
commandline:
\begin{verbatim}
 weka.core.CheckOptionHandler -W classname [-- additional parameters]
\end{verbatim}
All tests need to return \textit{yes}.

\subsubsection{GenericObjectEditor}
The CheckGOE class checks whether all the properties available in the GUI have a
tooltip accompanying them and whether the \texttt{globalInfo()} method is
declared:
\begin{verbatim}
 weka.core.CheckGOE -W classname [-- additional parameters]
\end{verbatim}
All tests, once again, need to return \textit{yes}.

\subsubsection{Source code}
Filters that implement the weka.filters.Sourcable interface can output Java code
of their internal representation. In order to check the generated code, one
should not only compile the code, but also test it with the following test
class:
\begin{verbatim}
 weka.filters.CheckSource
\end{verbatim}
This class takes the original Weka filter, the generated code and the dataset
used for generating the source code (and an optional class index) as parameters.
It builds the Weka filter on the dataset and compares the output, the one from
the Weka filter and the one from the generated source code, whether they are the
same.

Here's an example call for
\texttt{weka.filters.unsupervised.attribute.ReplaceMissingValues} and the
generated class \texttt{weka.filters.WekaWrapper} (it wraps the actual generated
code in a pseudo-filter):
\begin{verbatim}
 java weka.filters.CheckSource \
    -W weka.filters.unsupervised.attribute.ReplaceMissingValues \
    -S weka.filters.WekaWrapper \
    -t data.arff
\end{verbatim}
It needs to return \textit{Tests OK!}.

\subsubsection{Unit tests}
In order to make sure that your filter applies to the Weka criteria, you
should add your filter to the junit unit test framework, i.e., by creating a
Test class. The superclass for filter unit tests is
\texttt{weka.filters.AbstractFilterTest}.

%%%%%%%%%%%%%%%%%%%%%%%%%%
% Extending the Explorer %
%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section{Extending the Explorer}
The plugin architecture of the Explorer allows you to add new functionality
easily without having to dig into the code of the Explorer itself. In the
following you will find information on how to add new tabs, like the
``Classify'' tab, and new visualization plugins for the ``Classify'' tab.

\subsection{Adding tabs}
The Explorer is a handy tool for initial exploration of your data -- for
proper statistcal evaluation, the Experimenter should be used instead. But if
the available functionality is not enough, you can always add your own
custom-made tabs to the Explorer.

\subsubsection{Requirements}
Here is roughly what is required in order to add a new tab (the examples go into
more detail):
\begin{tight_itemize}
  \item your class must be derived from \texttt{javax.swing.JPanel}
  \item the interface \texttt{weka.gui.explorer.Explorer.ExplorerPanel} must be
implemented by your class
  \item optional interfaces
  \begin{tight_itemize}
	\item \texttt{weka.gui.explorer.Explorer.LogHandler} -- in case
you want to take advantage of the logging in the Explorer
	\item \texttt{weka.gui.explorer.Explorer.CapabilitiesFilterChangeListener}
-- in case your class needs to be notified of changes in the
Capabilities, e.g., if new data is loaded into the Explorer
  \end{tight_itemize}
  \item adding the classname of your class to the Tabs property in the
\texttt{Explorer.props} file
\end{tight_itemize}

\subsubsection{Examples}
The following examples demonstrate the new plugin architecture. Only the
necessary details are discussed, as the full source code is available for
download as well from the Weka Examples \cite{wekaexamples} (package
\texttt{wekaexamples.gui.explorer}).

\subsubsection*{SQL worksheet}
\subsubsection*{Purpose}
Displaying the SqlViewer as a tab in the Explorer instead of using it either via
the Open DB... button or as standalone application. Uses the existing components
already available in Weka and just assembles them in a JPanel. Since this tab
does not rely on a dataset being loaded into the Explorer, it will be used as a
standalone one.

Useful for people who are working a lot with databases and would like to have an
SQL worksheet available all the time instead of clicking on a button every time
to open up a database dialog.

\subsubsection*{Implementation}
\begin{tight_itemize}
  \item class is derived from \texttt{javax.swing.JPanel} and implements the
interface \texttt{weka.gui.Explorer.ExplorerPanel} (the full source code also
imports the \texttt{weka.gui.Explorer.LogHandler} interface, but that is only
additional functionality):
  \begin{verbatim}
  public class SqlPanel
    extends JPanel
    implements ExplorerPanel {
  \end{verbatim}

  \item some basic members that we need to have
  \begin{verbatim}
  /** the parent frame */
  protected Explorer m_Explorer = null;

  /** sends notifications when the set of working instances gets changed*/
  protected PropertyChangeSupport m_Support = new PropertyChangeSupport(this);
  \end{verbatim}

  \item methods we need to implement due to the used interfaces
  \begin{verbatim}
  /** Sets the Explorer to use as parent frame */
  public void setExplorer(Explorer parent) {
    m_Explorer = parent;
  }

  /** returns the parent Explorer frame */
  public Explorer getExplorer() {
    return m_Explorer;
  }

  /** Returns the title for the tab in the Explorer */
  public String getTabTitle() {
    return "SQL";  // what's displayed as tab-title, e.g., Classify
  }

  /** Returns the tooltip for the tab in the Explorer */
  public String getTabTitleToolTip() {
    return "Retrieving data from databases";  // the tooltip of the tab
  }

  /** ignored, since we //"generate"// data and not receive it */
  public void setInstances(Instances inst) {
  }

  /** PropertyChangeListener which will be notified of value changes. */
  public void addPropertyChangeListener(PropertyChangeListener l) {
    m_Support.addPropertyChangeListener(l);
  }

  /** Removes a PropertyChangeListener. */
  public void removePropertyChangeListener(PropertyChangeListener l) {
    m_Support.removePropertyChangeListener(l);
  }
  \end{verbatim}

  \newpage
  \item additional GUI elements
  \begin{verbatim}
  /** the actual SQL worksheet */
  protected SqlViewer m_Viewer;

  /** the panel for the buttons */
  protected JPanel m_PanelButtons;

  /** the Load button - makes the data available in the Explorer */
  protected JButton m_ButtonLoad = new JButton("Load data");

  /** displays the current query */
  protected JLabel m_LabelQuery = new JLabel("");
  \end{verbatim}

  \item loading the data into the Explorer by clicking on the Load button
will fire a property change:
  \begin{verbatim}
    m_ButtonLoad.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent evt){
        m_Support.firePropertyChange("", null, null);
      }
    });
  \end{verbatim}

  \item the propertyChange event will perform the actual loading of the data,
hence we add an anonymous property change listener to our panel:
  \begin{verbatim}
  addPropertyChangeListener(new PropertyChangeListener() {
    public void propertyChange(PropertyChangeEvent e) {
      try {
        // load data
        InstanceQuery query = new InstanceQuery();
        query.setDatabaseURL(m_Viewer.getURL());
        query.setUsername(m_Viewer.getUser());
        query.setPassword(m_Viewer.getPassword());
        Instances data = query.retrieveInstances(m_Viewer.getQuery());

        // set data in preprocess panel (also notifies of capabilties changes)
        getExplorer().getPreprocessPanel().setInstances(data);
      }
      catch (Exception ex) {
        ex.printStackTrace();
      }
    }
  });
  \end{verbatim}

  \item In order to add our \texttt{SqlPanel} to the list of tabs displayed in
the Explorer, we need to modify the \texttt{Explorer.props} file (just extract
it from the \texttt{weka.jar} and place it in your home directory). The Tabs
property must look like this:
  \begin{verbatim}
  Tabs=weka.gui.explorer.SqlPanel,\
       weka.gui.explorer.ClassifierPanel,\
       weka.gui.explorer.ClustererPanel,\
       weka.gui.explorer.AssociationsPanel,\
       weka.gui.explorer.AttributeSelectionPanel,\
       weka.gui.explorer.VisualizePanel
  \end{verbatim}
\end{tight_itemize}

\newpage
\subsubsection*{Screenshot}
\begin{center}
	\epsfig{file=images/extending/SqlPanel.eps,width=12cm}
\end{center}

\newpage
\subsubsection*{Artificial data generation}
\subsubsection*{Purpose}
Instead of only having a \textit{Generate...} button in the PreprocessPanel or
using it from commandline, this example creates a new panel to be displayed as
extra tab in the Explorer. This tab will be available regardless whether a
dataset is already loaded or not (= standalone).

\subsubsection*{Implementation}
\begin{tight_itemize}
  \item class is derived from \texttt{javax.swing.JPanel} and implements the
interface \texttt{weka.gui.Explorer.ExplorerPanel} (the full source code also
imports the \texttt{weka.gui.Explorer.LogHandler} interface, but that is only
additional functionality):
  \begin{verbatim}
  public class GeneratorPanel
    extends JPanel
    implements ExplorerPanel {
  \end{verbatim}

  \item some basic members that we need to have (the same as for the SqlPanel
class):
  \begin{verbatim}
  /** the parent frame */
  protected Explorer m_Explorer = null;

  /** sends notifications when the set of working instances gets changed*/
  protected PropertyChangeSupport m_Support = new PropertyChangeSupport(this);
  \end{verbatim}

  \item methods we need to implement due to the used interfaces (almost
identical to \texttt{SqlPanel}):
  \begin{verbatim}
  /** Sets the Explorer to use as parent frame */
  public void setExplorer(Explorer parent) {
    m_Explorer = parent;
  }
  /** returns the parent Explorer frame */
  public Explorer getExplorer() {
    return m_Explorer;
  }
  /** Returns the title for the tab in the Explorer */
  public String getTabTitle() {
    return "DataGeneration";  // what's displayed as tab-title, e.g., Classify
  }
  /** Returns the tooltip for the tab in the Explorer */
  public String getTabTitleToolTip() {
    return "Generating artificial datasets";  // the tooltip of the tab
  }
  /** ignored, since we "generate" data and not receive it */
  public void setInstances(Instances inst) {
  }
  /** PropertyChangeListener which will be notified of value changes. */
  public void addPropertyChangeListener(PropertyChangeListener l) {
    m_Support.addPropertyChangeListener(l);
  }
  /** Removes a PropertyChangeListener. */
  public void removePropertyChangeListener(PropertyChangeListener l) {
    m_Support.removePropertyChangeListener(l);
  }
  \end{verbatim}

  \newpage
  \item additional GUI elements:
  \begin{verbatim}
  /** the GOE for the generators */
  protected GenericObjectEditor m_GeneratorEditor = new GenericObjectEditor();

  /** the text area for the output of the generated data */
  protected JTextArea m_Output = new JTextArea();

  /** the Generate button */
  protected JButton m_ButtonGenerate = new JButton("Generate");

  /** the Use button */
  protected JButton m_ButtonUse = new JButton("Use");
  \end{verbatim}

  \item the Generate button does not load the generated data directly into the
Explorer, but only outputs in the \texttt{JTextArea} (this is done with the
\textit{Use} button - see further down):
  \begin{verbatim}
  m_ButtonGenerate.addActionListener(new ActionListener(){
    public void actionPerformed(ActionEvent evt){
      DataGenerator generator = (DataGenerator) m_GeneratorEditor.getValue();
      String relName = generator.getRelationName();

      String cname = generator.getClass().getName().replaceAll(".*\\.", "");
      String cmd = generator.getClass().getName();
      if (generator instanceof OptionHandler)
        cmd += " "+Utils.joinOptions(((OptionHandler)generator).getOptions());

      try {
        // generate data
        StringWriter output = new StringWriter();
        generator.setOutput(new PrintWriter(output));
        DataGenerator.makeData(generator, generator.getOptions());
        m_Output.setText(output.toString());
      }
      catch (Exception ex) {
        ex.printStackTrace();
        JOptionPane.showMessageDialog(
          getExplorer(), "Error generating data:\n" + ex.getMessage(),
          "Error", JOptionPane.ERROR_MESSAGE);
      }

      generator.setRelationName(relName);
    }
  });
  \end{verbatim}

  \item the \textit{Use} button finally fires a property change event that will
load the data into the Explorer:
  \begin{verbatim}
    m_ButtonUse.addActionListener(new ActionListener(){
      public void actionPerformed(ActionEvent evt){
        m_Support.firePropertyChange("", null, null);
      }
    });
  \end{verbatim}

  \newpage
  \item the propertyChange event will perform the actual loading of the data,
hence we add an anonymous property change listener to our panel:
  \begin{verbatim}
  addPropertyChangeListener(new PropertyChangeListener() {
    public void propertyChange(PropertyChangeEvent e) {
      try {
        Instances data = new Instances(new StringReader(m_Output.getText()));
        // set data in preprocess panel (also notifies of capabilties changes)
        getExplorer().getPreprocessPanel().setInstances(data);
      }
      catch (Exception ex) {
        ex.printStackTrace();
        JOptionPane.showMessageDialog(
          getExplorer(), "Error generating data:\n" + ex.getMessage(),
          "Error", JOptionPane.ERROR_MESSAGE);
      }
    }
  });
  \end{verbatim}

  \item In order to add our \texttt{GeneratorPanel} to the list of tabs
displayed in the Explorer, we need to modify the \texttt{Explorer.props} file
(just extract it from the \texttt{weka.jar} and place it in your home
directory). The Tabs property must look like this:
  \begin{verbatim}
  Tabs=weka.gui.explorer.GeneratorPanel:standalone,\
       weka.gui.explorer.ClassifierPanel,\
       weka.gui.explorer.ClustererPanel,\
       weka.gui.explorer.AssociationsPanel,\
       weka.gui.explorer.AttributeSelectionPanel,\
       weka.gui.explorer.VisualizePanel
  \end{verbatim}

\item \textbf{Note:} the standalone option is used to make the tab available
without requiring the preprocess panel to load a dataset first.
\end{tight_itemize}

\subsubsection*{Screenshot}
\begin{center}
	\epsfig{file=images/extending/GeneratorPanel.eps,width=12cm}
\end{center}

\newpage
\subsubsection*{Experimenter "light"}
\subsubsection*{Purpose}
By default the Classify panel only performs 1 run of 10-fold cross-validation.
Since most classifiers are rather sensitive to the order of the data being
presented to them, those results can be too optimistic or pessimistic. Averaging
the results over 10 runs with differently randomized train/test pairs returns
more reliable results. And this is where this plugin comes in: it can be used to
obtain statistical sound results for a specific classifier/dataset combination,
without having to setup a whole experiment in the Experimenter.

\subsubsection*{Implementation}
\begin{tight_itemize}
  \item Since this plugin is rather bulky, we omit the implementation details,
but the following can be said:
  \begin{tight_itemize}
	\item based on the \texttt{weka.gui.explorer.ClassifierPanel}
	\item the actual code doing the work follows the example in \textit{Using
the Experiment API} wiki article \cite{wekawiki}
  \end{tight_itemize}
  \item In order to add our \texttt{ExperimentPanel} to the list of tabs
displayed in the Explorer, we need to modify the \texttt{Explorer.props} file
(just extract it from the \texttt{weka.jar} and place it in your home
directory). The Tabs property must look like this:
  \begin{verbatim}
  Tabs=weka.gui.explorer.ClassifierPanel,\
       weka.gui.explorer.ExperimentPanel,\
       weka.gui.explorer.ClustererPanel,\
       weka.gui.explorer.AssociationsPanel,\
       weka.gui.explorer.AttributeSelectionPanel,\
       weka.gui.explorer.VisualizePanel
  \end{verbatim}
\end{tight_itemize}

\subsubsection*{Screenshot}
\begin{center}
	\epsfig{file=images/extending/ExperimentPanel.eps,width=12cm}
\end{center}

\newpage
\subsection{Adding visualization plugins}
\subsubsection*{Introduction}
As of Weka version 3.5.3 one can easily add visualization plugins in the
Explorer (Classify panel). This makes it easy to implement custom
visualizations, if the ones Weka offers are not sufficient. The following
examples can be found in the Examples collection \cite{wekaexamples} (package
\texttt{wekaexamples.gui.explorer}).

\subsubsection*{Requirements}
\begin{tight_itemize}
  \item custom visualization class must implement the following interface
  \begin{verbatim}
  weka.gui.visualize.plugins.VisualizePlugin
  \end{verbatim}
  
  \item the class must either reside in the following package (visualization
classes are automatically discovered during run-time)
  \begin{verbatim}
  weka.gui.visualize.plugins
  \end{verbatim}
  
  \item or the class' package must be listed in the
\texttt{weka.gui.visualize.plugins.VisualizePlugin} key of the
\texttt{weka/gui/GenericPropertiesCreator.props} file (or the equivalent in
your home directory).
\end{tight_itemize}

\subsubsection*{Implementation}
The visualization interface contains the following four methods
\begin{tight_itemize}
  \item \texttt{getMinVersion} -- This method returns the minimal version
(inclusive) of Weka that is necessary to execute the plugin, e.g., 3.5.0.
  \item \texttt{getMaxVersion} -- This method returns the maximal version
(exclusive) of Weka that is necessary to execute the plugin, e.g., 3.6.0.
  \item \texttt{getDesignVersion} -- Returns the actual version of Weka
this plugin was designed for, e.g., 3.5.1
  \item \texttt{getVisualizeMenuItem} -- The \texttt{JMenuItem} that is returned
via this method will be added to the plugins menu in the popup in the Explorer.
The \texttt{ActionListener} for clicking the menu item will most likely open a
new frame containing the visualized data.
\end{tight_itemize}

\newpage
\subsubsection*{Examples}
\subsubsection*{Table with predictions}
The \texttt{PredictionTable.java} example simply displays the actual class label
and the one predicted by the classifier. In addition to that, it lists whether
it was an incorrect prediction and the class probability for the correct class
label.
\begin{center}
	\epsfig{file=images/extending/PredictionTable.eps,width=12cm}
\end{center}

\newpage
\subsubsection*{Bar plot with probabilities}
The \texttt{PredictionError.java} example uses the JMathTools library (needs
the \texttt{jmathplot.jar} \cite{jmathplot} in the CLASSPATH) to display a
simple bar plot of the
predictions. The correct predictions are displayed in blue, the incorrect ones
in red. In both cases the class probability that the classifier returned for the
correct class label is displayed on the y axis. The x axis is simply the index
of the prediction starting with 0.
\begin{center}
	\epsfig{file=images/extending/PredictionError.eps,width=12cm}
\end{center}
