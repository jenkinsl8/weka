% Version: $Revision$

Using the graphical tools, like the Explorer, or the command-line is in most
cases sufficient for the normal user. But WEKA's clearly defined API
(``application programming interface'') makes is very easy to ``embed'' it in
another projects. This chapter covers some basics of how to achieve the
following common tasks from source code:
\begin{itemize}
	\item Option handling
	\item Loading data
	\item Filtering
	\item Classifying
	\item Clustering
	\item Selecting attributes
\end{itemize}

\noindent \textbf{Note} \\
\noindent WEKA is released under the GNU General Public License version
2\footnote{\url{http://www.gnu.org/licenses/gpl-2.0.html}{}} (GPLv2), i.e., that
derived
code or code that uses WEKA needs to be released under the GPLv2 as well. If
you are just using WEKA for a personal project that does not get released
publicly then you are not affected. But as soon as you make your project
publicly available (e.g., for download), then you need to make your source code
available under the GLPv2 as well, alongside the binaries.

\newpage

%%%%%%%%%%%%%%%%%%%
% Option handling %
%%%%%%%%%%%%%%%%%%%
\section{Option handling}
Configuring an object, e.g., a classifier, can either be done using the
appropriate get/set-methods for the property that you wish to change, like the
Explorer does. Or, if the class implements the \texttt{weka.core.OptionHandler}
interface, you can just use the object's ability to parse command-line options
via the \texttt{setOptions(String[])} method (the counterpart of this method is
\texttt{getOptions()}, which returns a \texttt{String[]} array). The
difference between the two approaches is, that the \texttt{setOptions(String[])}
method cannot be used to set the options incrementally. Default values are used
for all options that haven't been explicitly specified in the options array.

The most basic approach is to assemble the String array by hand. The following
example creates an array with a single option (``\texttt{-R}'') that takes an
argument (``\texttt{1}''):
\begin{verbatim}
  String[] options = new String[2];
  options[0] = "-R";
  options[1] = "1";
\end{verbatim}
Since the \texttt{setOptions(String[])} method expects a fully parsed and
correctly split up array (which is done by the command-line), some common
pitfalls with this approach are:
\begin{itemize}
	\item Combination of option and argument -- Using ``\texttt{-R 1}'' as an
element of the String array will fail, prompting WEKA to output an error message
stating that the option ``R 1'' is unknown.
	\item Trailing blanks -- Using ``\texttt{-R }'' will fail as well, since no
removal of trailing blanks happens and therefore option ``R '' is unknown.
\end{itemize}
The easiest way to avoid these problems, is to provide a String array that has
been generated automatically from a single command-line string using the
\texttt{splitOptions(String)} method of the \texttt{weka.core.Utils} class.
Here is an example:
\begin{verbatim}
  import weka.core.Utils;
  ...
  String[] options = Utils.splitOptions("-R 1");
\end{verbatim}
As this method ignores whitespaces, using ``\texttt{  -R    1}'' or
``\texttt{-R 1 }'' will return the same result as ``\texttt{-R 1}''.

Complicated command-lines with lots of nested options, e.g., options for the
support-vector machine classifier \textit{SMO} (package
\texttt{weka.classifiers.functions}) including a kernel setup, are a bit tricky,
since Java requires one to escape double quotes and backslashes inside a
String. The Wiki\cite{wekawiki} article ``Use Weka in your Java code''
references the Java class \texttt{OptionsToCode}, which turns any command-line
into appropriate Java source code.

\newpage

%%%%%%%%%%%%%%%%
% Loading data %
%%%%%%%%%%%%%%%%
\section{Loading data}
Before any filter, classifier or clusterer can be applied, data needs to be
present. WEKA enables one to load data from files (in various file formats) and
also from databases. In the latter case, it is assumed in that the database
connection is set up and working. See chapter \ref{databases} for more details
on how to configure WEKA correctly and also more information on JDBC (Java
Database Connectivity) URLs.

The following classes are used to store data in memory:
\begin{itemize}
	\item \texttt{weka.core.Instances} -- holds a complete dataset. This data
structure is row-based, single rows can be accessed via the
\texttt{instance(int)} method using a 0-based index. Information about the
columns can be accessed via the \texttt{attribute(int)} method. This method
returns \texttt{weka.core.Attribute} objects (see below).
	\item \texttt{weka.core.Instance} -- encapsulates a single row. It is
basically a wrapper around an array of double primitives. Since this class
contains no information about the type of the columns, it always needs access
to a \texttt{weka.core.Instances} object (see methods \texttt{dataset} and
\texttt{setDataset}). The class \texttt{weka.core.SparseInstance} is used in
case of sparse data.
	\item \texttt{weka.core.Attribute} -- holds the information about a single
column in the dataset. It stores the type of the attribute, as well as the
labels for \textit{nominal} attributes, the possible values for \textit{string}
attributes or the datasets for \textit{relational} attributes (these are just
\texttt{weka.core.Instances} objects again).
\end{itemize}

\subsection{Loading data from files}
When loading data from files, one can either let WEKA choose the appropriate
loader (the available loaders can be found in the \texttt{weka.core.converters}
package) based on the file's extension or one can use the correct loader
explicitly. The latter case is necessary if the files don't have the correct
extension.

The \texttt{DataSource} class (inner class of the
\texttt{weka.core.converters.ConverterUtils} class) can be used to read data
from files that have the appropriate file extension. Here are a some examples:
\begin{verbatim}
   import weka.core.converters.ConverterUtils.DataSource;
   import weka.core.Instances;
   ...
   Instances data1 = DataSource.read("/some/where/dataset.arff");
   Instances data2 = DataSource.read("/other/place/dataset.csv");
   Instances data3 = DataSource.read("/other/place/dataset.xrff");
\end{verbatim}
In case the file does have a different file extension than is normally
associated with the loader, one has to use a loader directly. The following
example loads a CSV file (``comma-separated values'') file:
\begin{verbatim}
   import weka.core.converters.CSVLoader;
   import weka.core.Instances;
   ...
   CSVLoader loader = new CSVLoader();
   loader.setSource(new File("/some/where/some.data"));
   Instances data = loader.getDataSet();
\end{verbatim}
\textbf{NB:} Not all file formats allow to store information about the class
attribute (e.g., ARFF stores no information about class attribute, but XRFF
does). If a class attribute is required further down the road, e.g., when using
a classifier, it can be set with the \texttt{setClassIndex(int)} method:
\begin{verbatim}
   // uses the first attribute as class attribute
   if (data.classIndex() == -1)
      data.setClassIndex(0);
   ...
   // uses the last attribute as class attribute
   if (data.classIndex() == -1)
      data.setClassIndex(data.numAttributes() - 1);
\end{verbatim}

\subsection{Loading data from databases}
For loading data from databases, you have two classes that allow you to do that:
\begin{itemize}
	\item \texttt{weka.experiment.InstanceQuery}
	\item \texttt{weka.core.converters.DatabaseLoader}
\end{itemize}
The differences between them are, that the \texttt{InstanceQuery} class allows
you to retrieve sparse data and the \texttt{DatabaseLoader} can retrieve the
data incrementally.

Here is an exaample of using the \texttt{InstanceQuery} class:
\begin{verbatim}
  import weka.core.Instances;
  import weka.experiment.InstanceQuery;
  ...
  InstanceQuery query = new InstanceQuery();
  query.setDatabaseURL("jdbc_url");
  query.setUsername("the_user");
  query.setPassword("the_password");
  query.setQuery("select * from whatsoever");
  // if your data is sparse, then you can say so too
  // query.setSparseData(true);
  Instances data = query.retrieveInstances();
\end{verbatim}

And an example using the \texttt{DatabaseLoader} class in ``batch retrieval'':
\begin{verbatim}
   import weka.core.Instances;
   import weka.core.converters.DatabaseLoader;
   ...
   DatabaseLoader loader = new DatabaseLoader();
   loader.setSource("jdbc_url", "the_user", "the_password");
   loader.setQuery("select * from whatsoever");
   Instances data = loader.getDataSet();
\end{verbatim}

\samepage
And in ``incremental mode'':
\begin{verbatim}
   import weka.core.Instance;
   import weka.core.Instances;
   import weka.core.converters.DatabaseLoader;
   ...
   DatabaseLoader loader = new DatabaseLoader();
   loader.setSource("jdbc_url", "the_user", "the_password");
   loader.setQuery("select * from whatsoever");
   Instances structure = loader.getStructure();
   Instances data = new Instances(structure);
   Instance inst;
   while ((inst = loader.getNextInstance(structure)) != null)
      data.add(inst);
\end{verbatim}
\textbf{Notes:}
\begin{itemize}
	\item Not all database systems allow incremental retrieval.
	\item Not all queries have a unique key to retrieve rows incrementally. In
that case, you can supply the necessary columns with the
\textit{setKeys(String)} method (comma-separated list of columns).
	\item If the data cannot be retrieved in an incremental fashion, it is first
loaded fully into memory and then provided row-by-row (``pseudo-incremental'').
\end{itemize}


%%%%%%%%%%%%%
% Filtering %
%%%%%%%%%%%%%
\section{Filtering}

%%%%%%%%%%%%%%%
% Classifying %
%%%%%%%%%%%%%%%
\section{Classifying}

%%%%%%%%%%%%%%
% Clustering %
%%%%%%%%%%%%%%
\section{Clustering}

%%%%%%%%%%%%%%%%%%%%%%%%
% Selecting attributes %
%%%%%%%%%%%%%%%%%%%%%%%%
\section{Selecting attributes}

%%%%%%%%%%%%%%%
% Saving data %
%%%%%%%%%%%%%%%
\section{Saving data}

\subsection{Saving data to files}

\subsection{Saving data to databases}
